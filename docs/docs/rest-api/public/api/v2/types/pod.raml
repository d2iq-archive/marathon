#%RAML 1.0 Library
annotationTypes: !include ../../annotations.raml
#annotationTypes:
#  scalaType: string
#  scalaPackage: string
uses:
  scaling-policy: scaling-policy.raml
types:
  Pod:
    (scalaType): PodDef
    description: |
      A pod allows one to launch a collection co-located (on the same agent) containers
      that share the same network namespace and that may share the same volumes.
      Resources are specified on a per-container basis.
    properties:
      id:
        type: string
        pattern: ^(\/?((\.{2})|([a-z0-9][a-z0-9\-.]*[a-z0-9]+)|([a-z0-9]*))($|\/))+$
        minLength: 1
        description: |
          Unique identifier for the pod consisting of a series of names separated by slashes.
          Each name must be at least 1 character and may only contain digits (`0-9`), dashes
          (`-`), dots (`.`), and lowercase letters (`a-z`). The name may not begin or end with a dash.
        example: /ops/audit
      labels?:
        type: array
        items: !include label.raml
        description: |
          Metadata as key/value pair.
          Useful when passing directives to be interpreted by Mesos modules.
      version?:
        type: datetime
        description: The version of the definition, immutable
      user?:
        type: string
        description: |
          The OS user to use to run the tasks on the agent.
          May be overridden by a container.
      environment?:
        type: array
        items: !include environmentVariable.raml
        description: |
          Environment Variables to set at the pod level.
          Individual containers may override them
        example: |
          [ { "name" : "MASTER_URI", "value": "http://master.local" },
            { "name" : "MASTER_PASSWORD", "secret": "/master/secret1" } ]
      containers:
        type: array
        items: !include mesosContainer.raml
      volumes?:
        type: array
        items: !include volume.raml
        description: Volumes defined on a pod level that are mounted into containers
      networks?:
        type: array
        items: !include network.raml
        description: |
          Network settings are defined on a pod level. All containers share the same network stack.
          At this time, only one stack is supported.
      scaling:
        type: scaling-policy.ScalingPolicy
        additionalProperties: false
        default:
          kind: fixed
          instances: 1
      scheduling?:
        type: object
        (scalaType): PodSchedulingPolicy
        properties:
          backoffStrategy?:
            type: object
            (scalaType): PodSchedulingBackoffStrategy
            description: |
              Configures exponential backoff behavior when launching potentially sick apps.
              This prevents sandboxes associated with consecutively failing tasks from filling up the hard disk on Mesos slaves.
              The backoff period is multiplied by the factor for each consecutive failure until it reaches maxLaunchDelaySeconds.
              This applies also to tasks that are killed due to failing too many health checks.
            properties:
              backoff?:
                type: number
                description: Configures exponential backoff behavior when launching potentially sick apps.
                minimum: 0
              backoffFactor?:
                type: number
                description: Configures exponential backoff behavior when launching potentially sick apps.
                minimum: 0
              maxLaunchDelay?:
                type: number
                description: Amount of time (seconds) until a pod is reported running
                minimum: 0
          upgradeStrategy?:
            type: object
            (scalaType): PodSchedulingUpgradeStrategy
            description: |
              During an upgrade all instances of an application get replaced by a new version.
              The upgradeStrategy controls how Marathon stops old versions and launches new versions.
            properties:
              minimumHealthCapacity?:
                type: number
                description: |
                  A number between 0and 1 that is multiplied with the instance count.
                  This is the minimum number of healthy nodes that do not sacrifice overall application purpose.
                  Marathon will make sure, during the upgrade process, that at any point of time this number of healthy instances are up.
                default: 1
                minimum: 0
                maximum: 1
              maximumOverCapacity?:
                type: number
                description: |
                  A number between 0 and 1 which is multiplied with the instance count.
                  This is the maximum number of additional instances launched at any point of time during the upgrade process.
                default: 1
                minimum: 0
                maximum: 1
          placement?:
            type: object
            (scalaType): PodSchedulingPlacementPolicy
            properties:
              constraints?:
                type: array
                items: !include constraint.raml
                description: |
                  Valid constraint operators are one of UNIQUE, CLUSTER, GROUP_BY, LIKE, UNLIKE, MAX_PER
              acceptedResourceRoles?:
                type: string[]
                example: [public-facing]
                description: |
                  A list of resource roles.
                  Marathon considers only resource offers with roles in this list for
                  launching tasks of this app. If you do not specify this,
                  Marathon considers all resource offers with roles that have been
                  configured by the `--default_accepted_resource_roles` command line flag.
                  If no `--default_accepted_resource_roles` was given on startup,
                  Marathon considers all resource offers. To register Marathon for a role,
                  you need to specify the `--mesos_role` command line flag on startup.
                  If you want to assign all resources of a slave to a role,
                  you can use the `--default_role` argument when starting up the slave.
                  If you need a more fine-grained configuration, you can use the
                  `--resources` argument to specify resource shares per role.
                  See [the Mesos attribute and resources documentation](http://mesos.apache.org/documentation/latest/attributes-resources/) for details
  PodStatus:
    (scalaType): PodStatus
    description: |
      Pod status communicates the lifecycle phase of the pod, current instance and container
      status, and recent termination status history.
    additionalProperties: false
    properties:
      id:
        type: !include pathId.raml
        description: |
          Fully qualified name of the pod that this status object is describing.
      spec:
        type: Pod
        description: |
          The latest version of the pod specification (that has the same pod ID).
      status:
        type: string
        (scalaType): PodState
        enum: [ DEGRADED, STABLE, TERMINAL ]
        description: |
          DEGRADED - The number of STABLE pod instances is less than the number of desired instances.
          STABLE   - All launched pod instances have started and, if health checks were specified, are all healthy.
          TERMINAL - Marathon is tearing down all of the instances for this pod.
      statusSince:
        type: datetime
        description: |
          Time at which the status code was last modified.
      message?:
        type: string
        description: |
          Human-friendly explanation for reason of the current status.
      instances?:
        type: array
        items:
          (scalaType): PodInstanceStatus
          type: !include pod-instance-status.raml
      terminationHistory?:
        type: array
        description: |
          List of most recent instance terminations.
          TODO(jdef) determine how many items might show up here; current thinking is .. not many
        items:
          (scalaType): TerminationHistory
          type: object
          additionalProperties: false
          properties:
            instanceID:
              type: string
            startedAt:
              type: datetime
            terminatedAt:
              type: datetime
            message?:
              type: string
              description: |
                Human-friendly explanation for termination.
      lastUpdated:
        type: datetime
        description: |
          Time that this status object was last checked and updated (even if nothing changed)
      lastChanged:
        type: datetime
        description: |
          Time that this status object was last modified (some aspect of status did change)
