#%RAML 1.0 Library
uses:
  constraints: constraint.raml
  label: label.raml
  strings: stringTypes.raml
  pragma: pragma.raml
  secrets: secrets.raml


types:
  AppCSIVolume:
    type: object
    properties:
      csi: ExternalCSIVolumeInfo
  ExternalCSIVolumeInfo:
    type: object
    properties:
      pluginName:
        type: string
      provisioning: StaticProvisioning
  StaticProvisioning:
    type: object
    additionalProperties: false
    properties:
      static:
        type: object
        properties:
          volumeId:
            type: string
            description: The ID of the volume to publish
          accessType: BlockOptions | MountOptions
          accessMode:
            type: string
            # TODO: shall we create a map for those to make the value more marathon'y?
            enum: [SINGLE_NODE_WRITER , SINGLE_NODE_READER_ONLY , MULTI_NODE_READER_ONLY , MULTI_NODE_SINGLE_WRITER , MULTI_NODE_MULTI_WRITER]
            description: |
              # TODO: is UNKNOWN a valid option? what does it default to?
              * `SINGLE_NODE_WRITER`       - Can only be published once as read/write on a single node, at any given time.
              * `SINGLE_NODE_READER_ONLY`  - Can only be published once as readonly on a single node, at any given time.
              * `MULTI_NODE_READER_ONLY`   - Can be published as readonly at multiple nodes simultaneously.
              * `MULTI_NODE_SINGLE_WRITER` - Can be published at multiple nodes simultaneously. Only one of the node can be used as read/write. The rest will be readonly.
              * `MULTI_NODE_MULTI_WRITER`  - Can be published as read/write at multiple nodes simultaneously.
          # TODO: no idea yet, what this is about. seems to clash with accessMode.
          readonly?:
            type: boolean
          volumeContext?:
            type: object
            description: |
              # TODO: more approachable description
              Volume context as returned by SP in CreateVolumeResponse.Volume.volume_context.
              This field is OPTIONAL and MUST match the volume_context of the volume identified by `volume_id`.

          # TODO: @tharper i feel like there should already be a way to obtain and pipe through secrets (https://github.com/apache/mesos/blob/master/include/mesos/v1/mesos.proto#L2861). it's not trivial for me to find that.
          # nodeStageSecret?:
          # nodePublishSecret?:

  # Empty for now. We could have also used a string here, but went with this more extensible approach.
  BlockOptions:
    type: object
    additionalProperties: false
    description: Indicate that the volume will be accessed via the block device API
    properties:
      block:
        type: object
  MountOptions:
    type: object
    additionalProperties: false
    properties:
      mount:
        type: object
        description: Indicate that the volume will be accessed via the filesystem API.
        properties:
          fsType?:
            type: string
            description: The filesystem type.
          mount_flags?:
            type: array
            description: |
              The mount options that can be used for the volume. MAY contain sensitive information. The total size SHALL NOT exceed 4 KiB.
            items:
              type: string
  ExternalVolumeInfo:
    type: object
    properties:
      size?:
        type: integer
        format: int64
        minimum: 0
        description: The size of the external volume in GiB
      name?:
        type: string
        description: The name of the volume
      provider?:
        type: string
        description: The name of the volume provider
      options?:
        type: label.KVLabels
        (pragma.omitEmpty):
        description: Provider specific volume configuration options
      shared?:
        type: boolean
        default: false
        description: If true, excludes this volume from the global unique volume name check
  PersistentVolumeType:
    type: string
    description: |
      The type of mesos disk resource to use; defaults to root if no profile name is specified.
      When specififying a profileName, this will default to mount.
    enum: [ root, path, mount ]
  PersistentVolumeInfo:
    type: object
    properties:
      type?:
        type: PersistentVolumeType
      size:
        type: integer
        format: int64
        minimum: 0
        description: The size of the persistence volume in MB.
      maxSize?:
        type: integer
        format: int64
        minimum: 0
        description: |
          For `mount` mesos disk resources, the optional maximum size of an exclusive mount volume to be considered.
      profileName?:
        type: string
        description: |
          The storage volume profile. Only volumes with the specified profile are used to launch an application.
          It this option is not given, any volume (with or without a profile) will be used for launching.
      constraints?:
        type: constraints.VolumeConstraint[]
        description: |
          Constraints restricting where new persistent volumes should be created.
          Currently, it is only possible to constrain the path of the disk resource by regular expression.
        uniqueItems: true

  PodEphemeralVolume:
    type: object
    properties:
      name:
        type: strings.Name
        description: The name of the volume to reference.
  AppExternalVolume:
    type: object
    properties:
      containerPath:
        type: string
        minLength: 1
        description: The path of the volume in the container
      external: ExternalVolumeInfo
      mode:
        type: strings.ReadMode
        description: Possible values are RO for ReadOnly and RW for Read/Write
  AppHostVolume:
    type: object
    properties:
      containerPath:
        type: string
        minLength: 1
        description: The path of the volume in the container
      hostPath:
        type: string
        minLength: 1
        description: The path of the volume on the host
      mode:
        type: strings.ReadMode
        description: Possible values are RO for ReadOnly and RW for Read/Write
  PodHostVolume:
    type: object
    properties:
      name:
        type: strings.Name
        description: The name of the volume to reference.
      host:
        type: string
        description: |
          Absolute path of the file or directory on the agent, or else the relative
          path of the directory in the executor's sandbox.
          Host volumes are useful for mapping directories that exist on the agent apriori,
          or within the executor sandbox. No resources (Mesos or otherwise) are allocated for
          these types of volumes.
  AppPersistentVolume:
    type: object
    properties:
      containerPath:
        type: string
        minLength: 1
        description: The path of the volume in the container
      persistent: PersistentVolumeInfo
      mode:
        type: strings.ReadMode
        description: Possible values are RO for ReadOnly and RW for Read/Write
  PodPersistentVolume:
    type: object
    properties:
      name:
        type: string
        minLength: 1
        description: Name of the pod level volume
      persistent: PersistentVolumeInfo
  AppSecretVolume:
    type: object
    properties:
      containerPath:
        type: string
        minLength: 1
        description: The path of the secret in the container
      secret:
        type: string
        minLength: 1
        description: References the secret that is used by this volume
  PodSecretVolume:
    type: object
    properties:
      name:
        type: string
        minLength: 1
        description: Name of the pod level volume
      secret:
        type: string
        minLength: 1
        description: References the secret that is used by this volume

  VolumeMount:
    type: object
    properties:
      name:
        type: strings.Name
        description: The name of the volume to reference.
      mountPath:
        type: strings.Path
        description: The path inside the container at which the volume is mounted.
      readOnly?:
        type: boolean

  AppVolume:
    type: AppPersistentVolume | AppExternalVolume | AppSecretVolume | AppHostVolume | AppCSIVolume
  PodVolume:
    # TODO: can we have pods with CSI volumes? We don't have DVDI Volumes... :thinking:
    type: PodPersistentVolume | PodSecretVolume | PodHostVolume | PodEphemeralVolume
